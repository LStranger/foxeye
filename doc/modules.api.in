    * * *  Modules for FoxEye: principles  * * *

Preamble.
---------
  All modules have the same interface - initialisation via ModuleInit()
    function, destroying via the signal S_TERMINATE. When module going
    to unload, all binds that were made on init must be deleted. Note:
    because module is being initialised on startup, neither listfile is
    loaded yet nor Wtmp is ready to get any events so don't use them on
    module initialization.
    Files in the module source: *.c, *.h - to compile, never installed;
    *.help - will be installed to help directory without last name part
    (i.e.".help"); accvs.m4, accvs.api, accvs.cfg and accvs.POTFILES -
    additions to main configure.in, doc/modules.api, core/foxeye.h and
    po/POTFILES.in, for Git only, are not distributable.
  Module have to have one or more of: interface, bind table, binding, or
    script interface. See descriptions below for ones.
  Each module is fully independent part with own functionality that may
    be written on any programming language. Module interoperable with
    other modules and core only via this API and any module CANNOT rely
    on any functionality beyond of this API. If you found something from
    existing code and that isn't stated in this document then be sure it
    may be changed in the future and it WILL be changed even. And if you
    think you cannot do something without hook then you just don't know
    that you can do it with no hooks. Enjoy! :)

What is an interface.
--------------------
  The interface is part of code what communicate with some resource(s).
    This may be: log file, session, IRC channel, another bot, etc. Each
    interface has appropriated INTERFACE structure that contains all data
    of that interface. Each interface may have two functions, one for
    requests (data message for interface), and one for signals (simple
    commands for interface to do something: shutdown, flush buffers, user
    programmed function, stop, etc.). If both of those functions are not
    set then this interface is considered as clone and in this case
    'prev' member of interface structure should be set to main interface.
    Another case when 'prev' member of interface structure is set is when
    you nesting some other interface locking previous and in that case
    you should set both signal function and request function. Case when
    there is no main interface for a clone is undefined and you should
    never create such interfaces. Data of the interface structure may be
    accessed only from bindings, from request function, or from signal
    function. To access data from threads you must lock dispatcher first
    (by calling Set_Iface() function). When you want to terminate some
    interface then you have to either send S_TERMINATE signal to it or
    set I_FINWAIT flag on it and dispatcher will terminate it by sending
    S_TERMINATE signal to it shortly. When interface has finished its job
    it has to set I_DIED flag on it within the same thread that called
    function Add_Iface() before. After that you CANNOT access any field
    of INTERFACE structure! As soon as I_DIED flag is set this interface
    will never get any signals or requests but some other things will be
    done by dispatcher:
    - any requests to it will be purged;
    - interface and his clones (if there are any) will be deleted from
      dispatcher;
    - 'data' member of the interface structure will be freed;
    - if that interface was nested then previous (stopped) interface will
      be awaken;
    - if that interface has nested interfaces then every of them will get
      S_TERMINATE signal;


What is a bind table.
-------------------
  The bind table is check table contains one or more bindings what can
    be checked for matching input string. Each bind table can be checked
    with only bot interface and must contain bindings one type and one
    purpose. In other words, when some event happens then bind table
    will be checked for matching to some key. Bind table there is a list
    of bindings for exactly one type of events.

What is a binding.
----------------
  The binding consist of string to match and bound function. When some
    input is matched to string, bound function is called. In other words,
    binding is key and function to react on some event (see description
    of bind table above). Bindings can be of two types: binary (which
    have interaction through C function call) and scripting (through some
    interpreter module, see documentation). Each type of bindings have
    own set of parameters and return values, see below.

Client records in listfile. Names convention.
------------------------------------------
  There are three types of names. First one is ordinary name, second one
    is special name, third one is composite name. Special name is a kind
    of extended one, it can be connected to us and it can play community
    role for others. Only composite names may (and have to) have a '@'
    char in them: name1@name2 where name1 is name of some network client
    or service and name2 is special name of local service. Local service
    may be either some network or directly connected service (IRC bot,
    for example). Network services (such as IRC channels) may have also
    additional '@' in names and local service name starts after last '@'
    then. Any and each local client has an ordinary name, any and each
    local service has a special name, clients and services at networks
    have composite names, and network clients exist only in runtime but
    will never be saved in listfile. Any "service" term below may be
    applied to any local or network services.
  Client may never have spaces, commas, control chars or colons within
    their name. All rest characters are permitted. Case conventions are
    locale-dependent.

Interpreters.
------------
  Basic interpreter is a config interpreter. No outside scripts can be
    run by it. Any other interpreter's interface may be loaded as module
    then config command "script" will run appropriate interpreter for
    that script file.

Async-unsafe functions.
---------------------
  These are functions that cannot be used in threads or interface signal
    handlers in part of S_SHUTDOWN.

Signals to interfaces.
--------------------
  SS__RREEPPOORRTT:
    Generate report and send it to current interface (see the Set_Iface()
    API). If it's not I_MODULE then report must be formatted via format
    string ReportFormat (see printl() for any details). If it's I_SERVICE
    then report for each client that has one of modeflags of ReportMask.
    Note that directive %N should be prepended with network specific char
    (flag) for the nick and some directives have other meanings in report
    format:
      %@ - generally "from" name not only host (bot name for example);
      %# - connection time string (in format of DateString+TimeString);
      %P - socket id (starting from 1, i.e. 0 means there is no socket);
      %L - if it's not I_SERVICE or I_CLIENT then interface name;
      %* - other descriptive text.
  SS__RREEGG:
    Reregister all module variables. If interface have to have line in
    config file then put that line as request to interface I_INIT with
    F_REPORT flag.
  SS__FFLLUUSSHH:
    Update infos, flush all streams.
  SS__SSTTOOPP:
    Pause the interface job, usually by setting I_LOCKED interface flag.
    Note: if flag I_LOCKED is set on interface then requests for that
    interface will be not received at all as if interface does not exist.
  SS__CCOONNTTIINNUUEE:
    Continue the interface job after stop. (also see note above)
  SS__SSHHUUTTDDOOWWNN:
    "Quiet" termination of interface. Don't release any memory and/or
    other resources, don't call any function but async-safe (see below),
    don't lock any mutexes, just close the files and connections. The
    message in variable SShhuuttddoowwnnRR may be used as shutdown reason.
  SS__TTEERRMMIINNAATTEE:
    Terminate the interface. It must stop any job doing by interface and
    release every resource that was touched on creating or in process
    (i.e. allocated memory, bindings, etc.) except associated data (it
    will be released by dispatcher itself). The signal receiver function
    must either set interface flag I_DIED or return I_DIED value. The
    message in variable SShhuuttddoowwnnRR may be used as termination reason.
  SS__TTIIMMEEOOUUTT:
    For interface internal usage.
  SS__LLOOCCAALL:
    For interface internal usage. Will use BindResult for parameters.

Shutdown process.
---------------
  Shutdown sequence: all IP connections; all modules; all left interfaces
  (if any of them survived). In case of normal shutdown every connection
  or module gets signal SS__TTEERRMMIINNAATTEE and all others SS__SSHHUUTTDDOOWWNN. Else every
  interface gets signal SS__SSHHUUTTDDOOWWNN. In any case variable SShhuuttddoowwnnRR may
  contain reason of shutdown.

Connection chains.
----------------
  There is an easy way to extend possibilities of connection by adding
  custom filters in the connection flow. Connection chain is chain of
  filters. Before you added some filters there is only raw connection
  but as soon you called Connchain_Grow() on that peer your connection
  is extended. For example, you can add SSL encription or on-the-fly
  compression. Each time you call Connchain_Grow() you can insert one
  filter on top of chain (on the bottom is raw connection you know) so
  when you send data to connection (via Connchain_Put()) they will go
  thru the chain from the top to the bottom and when you trying to get
  data from connection (via Connchain_Get()) then data will go from
  socket thru chain to top of it. There is no way to remove a filter
  from the chain because it may destroy all the connection flow so you
  have to build your chain carefully (inserting SSL handler as exactly
  first link for example). There are two ways to terminate a chain:
   - call KillSocket() on the socket; in that case Connchain_Put() will
     always return error but you have to call Connchain_Get() to get the
     data that may be still left in buffers until it returns error;
   - call Connchain_Get() on top of chain with NULL buffer pointer; in
     that case connection chain will be destroyed immediately and socket
     will be killed too.

Common API:
-----------
  Note for reenterability of all APIs:
    none means that function is non-reenterable and cannot be called
		from threads without locking of dispatcher, in some
		cases it may cause even deadlock;
    thread-safe means that function can be called from threads;
    reenterable means that function can be called recursively;
    async-safe means that function can be called even on shutdown.
  Threads can call any functions but non-reenterable.

  Note: main thread has dispatcher state locked on execution of any of
  interface functions so if you want call pthread_join() from there you
  must call Unset_Iface() before that and Set_Iface(NULL) after that.

  Also remember about deadlock possibility - if you have some mutex in
  your code and locked it while in thread then never ever try to call any
  function that signed thread-safe or reenterable until you unlock your
  mutex.

  None of non-reenterable nor async-safe functions is cancellation point.
  Also canceling of thread is disabled while dispatcher state is locked
  by the thread (see below).

  INTERFACE *AAdddd__IIffaaccee (iftype_t _t_y_p_e, const char *_n_a_m_e,
                        iftype_t (*_s_i_g___f_u_n_c) (INTERFACE *, ifsig_t),
			int (*_r_e_q___f_u_n_c) (INTERFACE *, REQUEST *),
			void *_d_a_t_a);
    Adds interface to dispatcher list. Returns pointer to new created
    interface with name _n_a_m_e and flags _t_y_p_e. Interface may have optional
    data _d_a_t_a associated with it. Names "@myname" and "*" have special
    meanings: interface with _n_a_m_e "@myname" is last resort, i.e. it will
    receive requests for "someone@myname" if interface with such name
    doesn't exist; interface with _n_a_m_e "*" will receive requests or
    signals to any interface of that _t_y_p_e. Each interface must have at
    least one of functions _r_e_q___f_u_n_c() for requests or _s_i_g___f_u_n_c() for
    signals. These functions may call any API functions since they may
    be called only when dispatcher is locked. Interface will be deleted
    from dispatcher list after interface flag I_DIED is set, _d_a_t_a will
    be deallocated by dispatcher then. Function _r_e_q___f_u_n_c() returns either
    REQ_OK if the request was accepted or REQ_REJECTED if it was not.
    Function _s_i_g___f_u_n_c() returns additional flags that MUST be set for
    interface by caller. Calling this with both _s_i_g___f_u_n_c and _r_e_q___f_u_n_c set
    to NULL is undefined behavior and should be used only if you want to
    use created interface as clone so you should set field 'prev' in the
    interface structure so dispatcher will use it for sending requests
    and signals instead. Note: when module terminating then you have to
    set interface flag I_DIED for each interface that was added on the
    module init. Note2: if you will use this interface as nested one so
    will set field 'prev' in the interface structure then you have define
    both _s_i_g___f_u_n_c and _r_e_q___f_u_n_c handlers.
	Reenterability: reenterable
	Cancellation point: no

  int RReennaammee__IIffaaccee (INTERFACE *_i_f_a_c_e, const char *_n_e_w_n_a_m_e);
    Renames the interface _i_f_a_c_e to new name _n_e_w_n_a_m_e. Changes mask of all
    requests queued exactly for it (without destination wildcards) with
    new name. Returns 1 on success or 0 if no matched interface found.
	Reenterability: reenterable
	Cancellation point: no

  INTERFACE *SSeett__IIffaaccee (INTERFACE *_i_f_a_c_e);
    Sets the interface _i_f_a_c_e as current for Add_Request(), New_Request(),
    or Get_Request() call. If _i_f_a_c_e is NULL then it's special case and
    current interface will be set to last one was set. Returns previous
    pointer to such interface and locks dispatcher state.
	Reenterability: thread-safe
	Cancellation point: no

  INTERFACE *FFiinndd__IIffaaccee (iftype_t _i_f_t, const char *_n_a_m_e);
    Finds interface with name _n_a_m_e that has all flags set of mask _i_f_t.
    Returns pointer to found interface and locks dispatcher state or
    returns NULL if no matched interface found. Note: name search is
    case-sensitive so if you want case-insensitive search then do case
    conversions yourself when adding interfaces.
	Reenterability: reenterable
	Cancellation point: no

  int UUnnsseett__IIffaaccee (void);
    Unlocks dispatcher state that was locked by previous call of function
    Set_Iface() or Find_Iface() and restore current interface that was
    before that call. Returns 0.
	Reenterability: reenterable
	Cancellation point: no

  void AAdddd__RReeqquueesstt (iftype_t _t_y_p_e, const char *_t_o, flag_t _f_l,
		    const char *_t_e_x_t, _._._.);
    Adds request for interfaces matched mask _t_o and flags _t_y_p_e. Request
    has mode flags _f_l. Data of request (from _t_e_x_t) is formated string or
    interface signal number if _f_l is F_SIGNAL. Request is recoded into
    target interface charset when added to queue. See simple_match() for
    mask details. Returns nothing.
	Reenterability: none if _f_l is F_SIGNAL, else reenterable
	Cancellation point: no

  void SSeenndd__SSiiggnnaall (iftype_t _t_y_p_e, const char *_t_o, ifsig_t _s_i_g);
    Macro, defined as Add_Request(_t_y_p_e, _t_o, F_SIGNAL, (char *)_s_i_g)
    Used for sending signals instead of text messages.
	Reenterability: none
	Cancellation point: no

  void NNeeww__RReeqquueesstt (INTERFACE *_i_f_a_c_e, flag_t _f_l, const char *_t_e_x_t, _._._.);
    Adds request for interface _i_f_a_c_e. Request has mode flags _f_l. Data of
    request (from _t_e_x_t) is formated string or interface signal number if
    _f_l is F_SIGNAL. Request is recoded into target interface charset when
    added to queue. Returns nothing.
	Reenterability: reenterable
	Cancellation point: no

  int RReellaayy__RReeqquueesstt (iftype_t _i_f_t, char *_n_a_m_e, REQUEST *_r_e_q);
    Requeues request _r_e_q for interfaces that are matched mask _n_a_m_e and
    flags _i_f_t. See simple_match() for mask details. Always returns value
    REQ_OK.
	Reenterability: reenterable
	Cancellation point: no

  int GGeett__RReeqquueesstt (void);
    Sends first request to current interface from its queue. Returns
    number of requests those was sent and deleted from queue.
	Reenterability: reenterable
	Cancellation point: no

  int AAdddd__HHeellpp (const char *_n_a_m_e);
    Adds help file to the help system. If current language isn't "C" and
    file _n_a_m_e.$LANG exists then loads that instead of _n_a_m_e. Returns 0 if
    file not found, nozero value otherwise.
	Reenterability: none

  void DDeelleettee__HHeellpp (const char *_n_a_m_e);
    Deletes help file _n_a_m_e from the help system. Returns nothing. You
    always have to call this function when module terminating for each
    help file added on module init.
	Reenterability: none

  int GGeett__HHeellpp (const char *_f_s_t, const char *_s_e_c, INTERFACE *_i_f_a_c_e,
		userflag _g_u_f, userflag _c_u_f, struct bindtable_t *_t_a_b_l_e,
		char *_p_r_e_f_i_x, int _m_o_d_e);
    Finds help matches first keyword _f_s_t and second keyword _s_e_c that are
    in bindtable _t_a_b_l_e and allowed for user with global userflags _g_u_f or
    channel userflags _c_u_f, then send help to that topics to interface
    _i_f_a_c_e. First line of sent help will begin with _p_r_e_f_i_x. If _m_o_d_e is 0
    then sent just usage, if _m_o_d_e is 1 then sent short description and
    otherwise full one. Special case 1: if _m_o_d_e is -1 then it works as
    if it is 0 but quietly if no help found. Special case 2: if _f_s_t is
    NULL but _s_e_c is not then assume first keyword is name of _t_a_b_l_e and
    _t_a_b_l_e is extension so check allowance for _s_e_c instead of _f_s_t. Note:
    if _t_a_b_l_e is NULL then assume allowance is granted. Returns number of
    found topics.
	Reenterability: none

  void ddpprriinntt (int _l_e_v_e_l, const char *_t_e_x_t, _._._.);
  void WWAARRNNIINNGG (const char *_t_e_x_t, _._._.);
  void EERRRROORR (const char *_t_e_x_t, _._._.);
    Prints debug message _t_e_x_t of given _l_e_v_e_l to all log interfaces. If
    _l_e_v_e_l is too high then message is discarded. WARNING() and ERROR()
    does the same with debug level 1 and 0 respectively but these levels
    does not produces just F_DEBUG messages but F_WARN or F_ERROR too.
    Note: it is a side effect, to enable warnings you have to start bot
    with debug level at least 1 and if you want to get warnings without
    debug then you should use Add_Request() call instead of WARNING().
	Reenterability: reenterable
	Cancellation point: no

  int mmaattcchh (const char *_m_a_s_k, const char *_s_t_r_i_n_g);
    Check whether the _s_t_r_i_n_g is matched mask _m_a_s_k. Returns number of
    characters (wildcards are not counted) that matched. Cases "*" in
    _m_a_s_k or in _s_t_r_i_n_g are special: match() returns 0. The mask is shell
    (tcsh, bash, etc.) expansion pattern and may contain:
      *		matched to any number of any characters
      ?		matched to one any character
      [list]	matched to any character in list
      [^list]	matched to any character not in list
		(list may contain any number of characters but ']' and
		'-' (which may be first ones) and may contain character
		ranges, i.e. c-g means cdefg)
      {pat1,pat2...} matched to any of patterns pat1, pat2, ...
      Aux+Beta	matched to literal string "Aux+Beta"
      \		quote next char
    Note: this function does not perform case-insensitive comparison!
	Reenterability: async-safe

  int ssiimmppllee__mmaattcchh (const char *_m_a_s_k, const char *_s_t_r_i_n_g);
    Check whether the _s_t_r_i_n_g is matched mask _m_a_s_k. Returns number of
    characters (wildcards are not counted) that matched. Cases "*" in
    _m_a_s_k or in _s_t_r_i_n_g are special: match() returns 0. The mask may
    contain:
      *		matched to any number of any characters
      ?		matched to one any character
      \		quote next *, ?, or \ char.
    Note: this function does not perform case-insensitive comparison!
	Reenterability: async-safe

  size_t ssttrrffccppyy (char *_d_s_t, const char *_s_r_c, size_t _n);
    Copies null-terminated text string _s_r_c to end of text string in the
    _d_s_t but don't exceed maximum string length _n of _d_s_t. In difference of
    strncpy() resulted string is always null-terminated. Returns size of
    filled _d_s_t (without null char).
	Reenterability: async-safe

  char *ssttrrffccaatt (char *_d_s_t, const char *_s_r_c, size_t _n);
    If _d_s_t is NULL or _n is 0 then returns 0. Else adds null-terminated
    text string _s_r_c to end of null-terminated text string in the _d_s_t but
    don't exceed maximum string length _n of _d_s_t. Returns _d_s_t.
	Reenterability: async-safe

  char *ggeettttookkeenn (char *_p_t_r, char **_e_o_w);
    Parses null-terminated string _p_t_r, puts a null char at the first word
    delimiter in it and if _e_o_w is not NULL then puts pointer to delimiter
    into _e_o_w. Returns pointer to next word in the parsed string. If there
    are no words left in the string then returns pointer to null char.
    Delimiter of words on parsing is space char.
	Reenterability: async-safe

  char *NNeexxttWWoorrdd (char *_m_s_g);
    Finds and returns next space-separated word in the text string _m_s_g.
    String _m_s_g is never modified by call.
	Reenterability: async-safe

  char *NNeexxttWWoorrdd__UUnnqquuootteedd (char *_a_r_g, char *_m_s_g, size_t _s);
    If first char in _m_s_g is double quotation mark then extracts all text
    up to next quotation mark into array _a_r_g of size _s and skip both
    quotation marks. Otherwise puts copy of space-separated word from the
    _m_s_g into _a_r_g. Returns pointer to the next word after extracted one.
    String _m_s_g is never modified by call.
	Reenterability: async-safe

  void SSttrrTTrriimm (char *_c_m_d);
    Chops all trailing spaces from string _c_m_d. Returns nothing.
	Reenterability: async-safe

  int HHaavvee__WWiillddccaarrdd (const char *_s_t_r);
    Checks null-terminated string _s_t_r for wildcards (see match() function
    for details). Returns value 0 or more if there is one, -1 otherwise.
	Reenterability: async-safe

  size_t pprriinnttll (char *_b_u_f, size_t _s, const char *_t_e_m_p_l, size_t _s_t_r_l_e_n,
		 char *_n_i_c_k, const char *_u_h_o_s_t, const char *_l_n_a_m_e,
		 char *_c_h_a_n, uint32_t _i_p, unsigned short _p_o_r_t, int _i_d_l_e,
		 const char *_m_e_s_s_a_g_e);
    Produces output in character array _b_u_f with size _s according to a
    format _t_e_m_p_l. Format string is composed of zero or more directives:
    ordinary characters (not %), which are copied unchanged to the output
    string and conversion specifications. Each conversion specification
    is introduced by the % character. Arguments: _n_i_c_k is argument for
    %N conversion, _u_h_o_s_t is argument for %@ conversion, _l_n_a_m_e is argument
    for %L conversion, _c_h_a_n is argument for %# conversion, _i_p is argument
    for %I conversion, _p_o_r_t is argument for %P conversion, _m_e_s_s_a_g_e is
    argument for %* conversion, _i_d_l_e is argument for %- conversion. All
    other details see in doc/help.format file. Argument _s_t_r_l_e_n is maximum
    size of each line (between LFs) in output. Returns size of produced
    string (without terminating null char).
	Reenterability: none

  const char *eexxppaanndd__ppaatthh (char *_b_u_f, const char *_s_t_r, size_t _s);
    If path _s_t_r begins from "~/" then substitutes that "~" by value of
    environment variable "HOME" in buffer _b_u_f with size _s and returns
    pointer to _b_u_f. Otherwise returns _s_t_r.
	Reenterability: async-safe

  size_t uunniissttrrlloowweerr (char *_d_s_t, const char *_s_r_c, size_t _s_z);
    Copies string text from _s_r_c to array in _d_s_t that has size _s_z and
    converts copied text to lower case according to current locale.
    Returns size of filled _d_s_t (without null char).
	Reenterability: async-safe

  size_t uunniissttrrccuutt (const char *_l_i_n_e, size_t _l_e_n, int _m_a_x_c_h_a_r_s);
    Checks null-terminated string in _l_i_n_e to contain not more than _l_e_n
    bytes (including termination byte) and also not more than _m_a_x_c_h_a_r_s
    characters (without null char) according to current locale. Returns
    size of chunk of string that complies to those conditions in bytes
    (without null char) so caller can truncate it. Does not modify _l_i_n_e.
	Reenterability: async-safe

  void *ssaaffee__ccaalllloocc (size_t _n_m_e_m_b, size_t _s_i_z_e);
  void *ssaaffee__mmaalllloocc (size_t _s_i_z_e);
  char *ssaaffee__ssttrrdduupp (const char *_s);
    Crash-free analogues of standard library functions. Uses the same
    syntax but shutdowns the bot instead of SIGSEGV if no memory left
    available to allocate. safe_strdup() also returns NULL and does not
    allocate memory if tries to duplicate empty string.
	Reenterability: thread-safe
	Cancellation point: no

  void ssaaffee__ffrreeee (void **_p_t_r);
  void ssaaffee__rreeaalllloocc (void **_p_t_r, size_t _s);
    Crash-free analogues of standard library functions. Shutdowns the
    bot instead of SIGSEGV if no memory left available to allocate. In
    difference of standard library's free() and realloc() also updates
    data in _p_t_r so in case of zero-lenght data it will contain NULL
    after return. Returns nothing.
	Reenterability: thread-safe
	Cancellation point: no

  size_t ssaaffee__ssttrrlleenn (const char *_s);
  char *ssaaffee__ssttrrcchhrr(char *_s, int _c);
  int ssaaffee__ssttrrccmmpp (const char *_s_1, const char *_s_2);
  int ssaaffee__ssttrrnnccmmpp (const char *_s_1, const char *_s_2, size_t _n);
  int ssaaffee__ssttrrccaasseeccmmpp (const char *_s_1, const char *_s_2);
  int ssaaffee__ssttrrnnccaasseeccmmpp (const char *_s_1, const char *_s_2, size_t _n);
    Crash-free analogues of standard library functions. Uses the same
    syntax but does not produce SIGSEGV in case of NULL arguments.
	Reenterability: async-safe

  unsigned short make_hash (const char *str);
	Reenterability: async-safe

  int Merge_Listfile (char *path);

  void bboott__sshhuuttddoowwnn (char *_m_e_s_s_a_g_e, int _e);
    Does full shutdown. Used mostly in case of critical errors. Returns
    never, _m_e_s_s_a_g_e will be used as shutdown reason, _e will be used as
    program exit code.
	Reenterability: none

Bindings API:
-------------
  struct bindtable_t *AAdddd__BBiinnddttaabbllee (const char *_n_a_m_e, bttype_t _t_y_p_e);
    Registers bindtable with some _n_a_m_e of some _t_y_p_e. Returns pointer to
    structure associated with _n_a_m_e. Subsequent call of Check_Bindtable()
    function will check that bindtable. If bindtable with the same name
    already exists then returns pointer to it and otherwise pointer to
    new created one. If _t_y_p_e is not B_UNDEF and was B_UNDEF on previous
    call of Add_Bindtable() then converts bindtable to this _t_y_p_e.
	Reenterability: none

  struct binding_t *CChheecckk__BBiinnddttaabbllee (struct bindtable_t *_t_a_b_l_e,
				     const char *_s_t_r, userflag _g_u_f,
				     userflag _c_u_f, struct binding_t *_l_a_s_t);
    Checks bindtable _t_a_b_l_e for entries matched string _s_t_r for users with
    matching combination of global userflags _g_u_f and userflags for some
    service _c_u_f (see Add_Binding() description for more details). Returns
    first matched binding if _l_a_s_t equal NULL. Returns next match if _l_a_s_t
    is last found binding and if bindtable type is KEYWORD (see below)
    then search will be done by previous literal ignoring _s_t_r.
	Reenterability: none

  const char *BBiinnddttaabbllee__NNaammee (struct bindtable_t *_t_a_b_l_e);
    Returns name of already registered bindtable _t_a_b_l_e.
	Reenterability: async-safe

  struct binding_t *AAdddd__BBiinnddiinngg (const char *_t_a_b_l_e_n_a_m_e, const char *_m_a_s_k,
				 userflag _g_u_f, userflag _c_u_f,
				 Function _f_u_n_c, const char *_f_n_a_m_e);
    Adds binding to bindtable _t_a_b_l_e_n_a_m_e. Strings checked via bindtable
    have to match string _m_a_s_k with current type of mathcing and clients
    (or any events that will be checked by Check_Bindtable() afterwards)
    must have matched combination of global userflags _g_u_f and selected
    service userflags _c_u_f to be available. By default userflags are
    matched if client's global flags have all bits set which are set in
    _g_u_f or if client's selected service flags have all bits set which are
    set in _c_u_f but that behavior can be extended: if any _g_u_f or
    _c_u_f have set bit U_NEGATE then userflags will be matched when
    appropriate client's flags have no one bit set of those that are set
    in binding's ones; and if _c_u_f have set bit U_AND then userflags are
    matched if client's global flags have all bits set which are set in
    _g_u_f and also client's selected service flags have all bits set which
    are set in _c_u_f. Argument _f_u_n_c points to function associated with that
    binding. If _f_n_a_m_e is not NULL then _f_u_n_c points to script interpreter
    which will get _f_n_a_m_e as first parameter (see below). See match() for
    _m_a_s_k details if bindtable is B_MASK or B_UNIQMASK type. Returns
    pointer to new added binding. Note: _m_a_s_k must be a lowercase string
    until bindtable is B_MATCHCASE type.
	Reenterability: none

  void DDeelleettee__BBiinnddiinngg (const char *_t_a_b_l_e_n_a_m_e, Function _f_u_n_c,
		       const char *_f_n_a_m_e);
    Deletes bindings that returning _f_u_n_c from bindtable _t_a_b_l_e_n_a_m_e. If
    _f_n_a_m_e is NULL then deletes all matched bindings, otherwise deletes
    bindings with the same name for script interpreter. Returns nothing.
    You always have to call this function when module terminating for
    each binding added on module init.
	Reenterability: none

  int RRuunnBBiinnddiinngg (struct binding_t *_b_i_n_d, const unsigned char *_u_s_e_r,
		  const char *_f_s_t, const char *_s_e_c, char *_t_h_i_r_d, int _n_u_m,
		  const char *_l_a_s_t);
    Runs script binding defined at _b_i_n_d, with arguments, formed from _u_s_e_r
    splitted to nick and user@host, strings _f_s_t, _s_e_c, _t_h_i_r_d, _l_a_s_t, and
    integer _n_u_m in order they are in function call. Any NULL values or
    empty strings _f_s_t and _s_e_c are ignored, negative _n_u_m too. If value of
    _t_h_i_r_d consists of space separated words then it will be splitted to
    first word and rest. Returns 0 if binding returned 0 or 1 otherwise.
    Any error processing should be done by interpreter module.
	Reenterability: none  (binding must be since Check_Bindtable)

  int LLnnaammee__IIssOOnn (const char *_n_e_t, const char *_p_u_b_l_i_c, const char *_l_n_a_m_e,
		  const char **_n_a_m_e);
    Checks if someone _l_n_a_m_e is currently online for me in the community
    _p_u_b_l_i_c on network _n_e_t. Returns 0 if it isn't and not 0 otherwise. If
    pointer _n_a_m_e is not NULL then on return it will point to string that
    contains last seen nick of this client. If _l_n_a_m_e is NULL then checks
    for own nickname on that network service. _p_u_b_l_i_c may be NULL.
	Reenterability: none

  modeflag IInnssppeecctt__CClliieenntt (const char *_n_e_t, const char *_p_u_b_l_i_c,
			   const char *_n_a_m_e, const char **_l_n_a_m_e,
			   const char **_h_o_s_t, time_t *_i_d_l_e, short *_c_n_t);
    Checks if someone with nick _n_a_m_e is currently in community _p_u_b_l_i_c on
    network _n_e_t. Returns modeflags of _n_a_m_e and if _n_a_m_e is NULL then
    returns modeflags the community currently has. If _l_n_a_m_e is not NULL
    then on return it will point to string that contains Lname of this
    client. If _h_o_s_t is not NULL then on return it will point to string
    that contains host string (host or user@host) of this client. If _i_d_l_e
    is not NULL then on return it will contain timestamp of last event
    for this client. If _c_n_t is not NULL then on return it will contain
    service-specific data counter (see also NewEvent() function). If _n_a_m_e
    is NULL then _h_o_s_t will point to string that contains community topic.
    If _n_a_m_e is hostmask (nick!user@host) then _h_o_s_t will point to string
    containing matched mode for the community (for example, ban mask). In
    last two cases _l_n_a_m_e will point to string that contains nick of the
    client who made that change. If _p_u_b_l_i_c is NULL then checks global
    modeflags for the _n_a_m_e (which can be only client name in this case)
    in the network.
	Reenterability: none

Listfile API:
-------------
  int AAdddd__CClliieennttrreeccoorrdd (const char *_n_a_m_e, const unsigned char *_m_a_s_k,
			userflag _u_f);
    Adds user with Lname _n_a_m_e, hostmask _m_a_s_k (in form of nick!user@host
    for common users) and global userflags _u_f to Listfile. See match()
    description for hostmask details. If _n_a_m_e contains no '.' then _m_a_s_k
    will be normalized (i.e. lowercased) on adding. Returns nonull value
    if successful.
	Reenterability: none

  int AAdddd__AAlliiaass (const char *_n_a_m_e, const char *_o_w_n_e_r);
    Adds user with Lname _n_a_m_e as alias for user with Lname _o_w_n_e_r to
    Listfile. Returns nonull value if successful.
	Reenterability: none

  void DDeelleettee__CClliieennttrreeccoorrdd (const char *_n_a_m_e);
    Deletes user/alias with Lname _n_a_m_e from Listfile. Returns nothing.
	Reenterability: none

  int CChhaannggee__LLnnaammee (const char *_n_n_e_w, const char *_n_o_l_d);
    Changes user Lname _n_o_l_d with new Lname _n_n_e_w in Listfile. Returns 1
    if successful, 0 otherwise.
	Reenterability: none

  userflag ssttrrttoouusseerrffllaagg (const char *_p_t_r, char **_e_n_d_p_t_r);
    Converts text string at _p_t_r to userflag. The string may begin with
    an arbitrary amount of white space. If _e_n_d_p_t_r is not NULL then the
    function stores the address of first invalid character in *_e_n_d_p_t_r.
	Reenterability: async-safe

#include "list.h"

  struct clrec_t *FFiinndd__CClliieennttrreeccoorrdd (const unsigned char *_m_a_s_k,
				     const char **_n_a_m_e, userflag *_u_f,
				     const char *_n_e_t);
    Finds user that is matched to hostmask _m_a_s_k (nick!ident@host]) and
    gets his user login _n_a_m_e (Lname below) and his userflags _u_f compiled
    from global flags and flags for network _n_e_t (if _n_e_t is NULL then for
    direct service). Locks Listfile record of that user. Returns pointer
    to internal Listfile record structure. Function never can find any
    special user record or alias. Note: Locks in core are complex so
    until you want deadlock NEVER use Listfile API calls from above or
    any API calls that are marked as thread-safe or reenterable while any
    record in Listfile is locked! Note2: this function will scan whole
    Listfile database so can be slow sometimes and for the best you have
    to use it as few as possible.
	Reenterability: thread-safe
	Cancellation point: no

  struct clrec_t *LLoocckk__CClliieennttrreeccoorrdd (const char *_n_a_m_e);
    Locks Listfile record of user with Lname _n_a_m_e. Returns pointer to
    internal Listfile record structure or NULL if user was not found.
    Note: Locks in core are complex so until you want deadlock NEVER use
    Listfile API calls from above or any API calls that are marked as
    thread-safe or reenterable while any record in Listfile is locked!
	Reenterability: thread-safe
	Cancellation point: maybe

  struct clrec_t *LLoocckk__bbyyLLIIDD (lid_t _i_d);
    Attempts to lock Listfile record of user with LID _i_d. Returns pointer
    to internal Listfile record structure or NULL if user was not found.
    Note: Locks in core are complex so until you want deadlock NEVER use
    Listfile API calls from above or any API calls that are marked as
    thread-safe or reenterable while any record in Listfile is locked!
    Note2: there is a small chance that there is another record on that
    LID already in case if someone deleted record of that LID and created
    new one after you've got that _i_d so this method of access to Listfile
    record might be considered unreliable.
	Reenterability: thread-safe
	Cancellation point: maybe

  void UUnnlloocckk__CClliieennttrreeccoorrdd (struct clrec_t *_u_s_e_r);
    Unlocks Listfile record locked by previous call Find_Clientrecord(),
    Lock_Clientrecord(), or Lock_byLID() function. Returns nothing.
	Reenterability: thread-safe
	Cancellation point: no

  char *GGeett__FFiieelldd (struct clrec_t *_u_s_e_r, const char *_f_n, time_t *_t_i_m_e);
    Returns content of Listfile field _f_n for user with internal Listfile
    record structure at _u_s_e_r. If _f_n is "" then returns current direct
    service console settings as string in form "console flags<space>
    default service name<space>botnet channel number". If _f_n is NULL
    then returns Lname for this record (so if it was alias originally
    then returned value will be "host" Lname). If parameter _t_i_m_e is not
    NULL then it may get some value: if _f_n is NULL then it gets record
    creation time, if _f_n is a special or composite name then it gets
    field's expiration time (that is used for bans, for example). Note:
    special name must be prepended with '@' to make difference with
    custom field names and custom field name should not have '@' nor ':'
    within it.
	Reenterability: thread-safe
	Cancellation point: no

  int SSeett__FFiieelldd (struct clrec_t *_u_s_e_r, const char *_f_n, const char *_v_a_l,
		 time_t _t_i_m_e);
    Sets content of Listfile field _f_n for user with internal Listfile
    record structure at _u_s_e_r with value _v_a_l. Returns nonull value if
    success. If _f_n is "" then sets direct service console settings for
    the user. If _t_i_m_e isn't 0 and _f_n is a service name then sets it as
    field's expiration time. Note: if _f_n is "alias", Set_Field() will do
    not change Listfile (delete old & add new aliases) so you must do it
    yourself. Note2: if _f_n is a special name then that name must be
    prepended with '@' to make difference with custom field names and
    custom field name should not have '@' nor ':' within it. Note3: if _f_n
    is one of standard fields ("info" for example) then it cannot contain
    any ':' in the _v_a_l.
	Reenterability: none

  int GGrrooww__FFiieelldd (struct clrec_t *_u_s_e_r, const char *_f_n, const char *_v_a_l);
    If Listfile record structure _u_s_e_r has not field _f_n yet then
    does the same as previous function. Otherwise adds space and value
    _v_a_l to end of string field _f_n. Returns nonull value on success.
    Note: if _f_n is "alias", Grow_Field() will do not change Listfile
    (delete old & add new aliases) so you must do it yourself. Note2: if
    _f_n is a special name then that name must be prepended with '@' to
    make difference with custom field names and custom field name should
    not have '@' nor ':' within it. Note3: maximum length of resulted
    field is limited to 1024 bytes.
	Reenterability: none

  int AAdddd__MMaasskk (struct clrec_t *_u_s_e_r, const unsigned char *_m_a_s_k);
    Adds hostmask _m_a_s_k (usually in form of nick!user@host) for user with
    internal Listfile record structure at _u_s_e_r. See match() for hostmask
    details. If _u_s_e_r name contains no '.' then _m_a_s_k will be normalized
    (i.e. lowercased) on adding. Returns nonull value if successful.
	Reenterability: none

  int DDeelleettee__MMaasskk (struct clrec_t *_u_s_e_r, const unsigned char *_m_a_s_k);
    Deletes all hostmasks matching _m_a_s_k from user with internal Listfile
    record structure at _u_s_e_r. See match() for _m_a_s_k details. Returns -1
    if no hostmasks left in the record.
	Reenterability: none

  userflag GGeett__FFllaaggss (struct clrec_t *_u_s_e_r, const char *_s_e_r_v);
    Returns userflags of user with internal Listfile record structure at
    _u_s_e_r for service _s_e_r_v. If _s_e_r_v is "" then returns direct service
    and global userflags. If _s_e_r_v is NULL then returns global userflags.
	Reenterability: thread-safe
	Cancellation point: no

  userflag SSeett__FFllaaggss (struct clrec_t *_u_s_e_r, const char *_s_e_r_v, userflag _u_f);
    Attempts to set userflags on internal Listfile record structure at
    _u_s_e_r for service _s_e_r_v according to _u_f. If _s_e_r_v is NULL then sets
    direct service and global userflags. Take in consideration that some
    of flags are immutable and cannot be changed with this function (for
    example, you cannot convert normal client record into special one).
    Returns userflags that are set now for service _s_e_r_v or 0 in case of
    error.
	Reenterability: none

  lid_t GGeett__LLIIDD (struct clrec_t *_u_s_e_r);
    Returns LID for client with internal Listfile record _u_s_e_r. Returned
    LID is valid until it deleted from Listfile (you can be notified on
    that via bindtable "new-lname").
	Reenterability: thread-safe
	Cancellation point: no

  userflag GGeett__CClliieennttffllaaggss (const char *_n_a_m_e, const char *_s_e_r_v);
    Returns userflags of user with Lname _n_a_m_e for service _s_e_r_v. If _s_e_r_v
    is "" then returns direct service and global userflags. If _s_e_r_v is
    NULL then returns global userflags.
	Reenterability: thread-safe
	Cancellation point: maybe

  int GGeett__CClliieennttlliisstt (INTERFACE *_i_f_a_c_e, userflag _u_f, const char *_f_n,
		      const char *_m_a_s_k);
    Sends list (space separated) of known Lnames which have global
    userflags any of _u_f and Listfile field _f_n matched _m_a_s_k, to interface
    _i_f_a_c_e via New_Request(). If checked for bans (_u_f contains appropriate
    flag) or if _f_n is NULL then Lnames and hostmasks will be checked
    against _m_a_s_k. If _f_n is a service name then userflags for that service
    will be checked to contain any of _u_f too in case global userflags
    were not matched. If found Listfile record is "nonamed" ban then it's
    hostmask will be sent instead of missing Lname. Returns number of
    requests that were sent. Note: if _f_n is a special name then that name
    must be prepended with '@' to make difference with custom field
    names.
	Reenterability: none

  int GGeett__HHoossttlliisstt (INTERFACE *_i_f_a_c_e, lid_t _i_d);
    Sends list (space separated) of known hosts for Listfile record with
    LID _i_d to interface _i_f_a_c_e via New_Request(). Returns number of
    requests that were sent. Note: it's required that you get your _i_d
    right away so there will be no chance to get another record on that
    LID.
	Reenterability: none

  int GGeett__FFiieellddlliisstt (INTERFACE *_i_f_a_c_e, lid_t _i_d);
    Sends list (space separated) of known fields for Listfile record with
    LID _i_d to interface _i_f_a_c_e via New_Request(). Only services (either
    special or composite names) or user-defined field names will be sent.
    Returns number of requests that were sent. Note: it's required that
    you get your _i_d right away so there will be no chance to get another
    record on that LID. Note2: special names in reports will be prepended
    with '@' to make difference with custom field names.
	Reenterability: none

  userflag MMaattcchh__CClliieenntt (const char *_h_o_s_t, const char *_i_d_e_n_t,
			 const char *_n_a_m_e);
    Returns OR'ed userflags for all found Listfile records matched to
    users with hostmask _i_d_e_n_t@_h_o_s_t and with Lname mask _n_a_m_e.
	Reenterability: thread-safe
	Cancellation point: no

  lid_t FFiinnddLLIIDD (const char *_n_a_m_e);
    Returns LID for client with Lname _n_a_m_e. Returned LID is valid until
    it deleted from Listfile (you can be notified on that via bindtable
    "new-lname").
	Reenterability: thread-safe
	Cancellation point: maybe

  char *uusseerrffllaaggttoossttrr (userflag _f_l_a_g_s, char *_b_u_f_f);
    Converts _f_l_a_g_s to string and prints it to buffer _b_u_f_f. Returns _b_u_f_f
    pointer. Note: buffer must be long enough to get the string.
	Reenterability: async-safe

  unsigned short Get_Hosthash (const char *lname, const char *host);
	Reenterability: none

Wtmp API:
---------
#include "wtmp.h"

  short EEvveenntt (const char *_e_v_e_n_t);
    Returns event number by it name _e_v_e_n_t.
	Reenterability: thread-safe
	Cancellation point: yes

  int FFiinnddEEvveenntt (struct wtmp_t *_t_e_m_p, const char *_u_s_e_r, short _e_v_e_n_t,
		 lid_t _i_d, time_t _u_p_t_o);
    Finds last event for Lname _u_s_e_r and it number _e_v_e_n_t that was logged
    from some service _i_d not earlier than _u_p_t_o and writes it to array
    _t_e_m_p. Returns -1 if there was an error and 0 otherwise. If _e_v_e_n_t is
    W_ANY, the function finds any evend for that _i_d. If _i_d is ID_ME then
    finds the event on any service, if _i_d is ID_ANY then finds the event
    on any service but direct. If there was no event found then returns
    _t_e_m_p zeroed.
	Reenterability: thread-safe
	Cancellation point: yes

  int FFiinnddEEvveennttss (struct wtmp_t *_t_e_m_p, int _w_s, const char *_u_s_e_r,
		  short _e_v_e_n_t, lid_t _i_d, time_t _u_p_t_o)
    Finds not more than _w_s last events for Lname _u_s_e_r and it number _e_v_e_n_t
    that was logged from some service _i_d not earlier than _u_p_t_o and writes
    it to array _t_e_m_p of size _w_s in order that last event goes into cell
    _t_e_m_p[0] and so on. Returns number of found events. If _e_v_e_n_t is W_ANY,
    the function finds any evend for that _i_d. If _i_d is ID_ME then finds
    the event on any service, if _i_d is ID_ANY then finds the event on any
    service but direct.
	Reenterability: thread-safe
	Cancellation point: yes

  void NNeewwEEvveenntt (short _e_v_e_n_t, lid_t _f_r_o_m, lid_t _i_d, short _n_u_m);
  void NNeewwEEvveennttss (short _e_v_e_n_t, lid_t _f_r_o_m, size_t _n,
		  lid_t *_i_d, short *_n_u_m);
    Adds one or _n new event record(s) to Wtmp file for client _i_d, its
    number _e_v_e_n_t, some service _f_r_o_m with event specific data _n_u_m. For
    event W_END on any service that data should be number of client's
    activities since corresponding event W_START of that client. Returns
    nothing. Note: don't call it with _e_v_e_n_t W_DOWN from threads!
	Reenterability: async-safe if _e_v_e_n_t is W_DOWN, else thread-safe
	Cancellation point: no

Sheduler-timer API:
-------------------
#include "sheduler.h"

  void NNeewwSShheedduullee (iftype_t _i_f_t, const char *_n_a_m_e, ifsig_t _s_i_g,
		   char *_m_i_n, char *_h_r, char *_d_s, char *_m_n, char *_w_k);
    Sets new shedule mask for some minutes _m_i_n, hours _h_r, days _d_s of
    months _m_n on day of week _w_k. Each of these submasks is comma
    separated list of times: "*[/i]" or "a[-b[/i]]". First format means
    do the job each i, second means do each i in interval a to b, that
    range is inclusive. If i is omitted then assume it's equal 1, if b
    is omitted then assume it's equal to a. Allowed values: _m_i_n 0-59,
    _h_r 0-23, _d_s 1-31, _m_n 1-12, _w_k 0-7, since real time will never reach
    other. When shedule is matched then signal _s_i_g will be sent to
    interface _n_a_m_e with type _i_f_t. Returns nothing.
	Reenterability: thread-safe
	Cancellation point: no

  void KKiillllSShheedduullee (iftype_t _i_f_t, const char *_n_a_m_e, ifsig_t _s_i_g,
		    char *_m_i_n, char *_h_r, char *_d_s, char *_m_n, char *_w_k);
    Aborts shedule mask. Synopsis equal to NewShedule().
	Reenterability: thread-safe
	Cancellation point: no

  tid_t NNeewwTTiimmeerr (iftype_t _i_f_t, const char *_n_a_m_e, ifsig_t _s_i_g,
		  unsigned int _s_e_c, unsigned int _m_i_n, unsigned int _h_r,
		  unsigned int _d_s);
    Set new shedule job for _s_e_c seconds, _m_i_n minutes, _h_r hours and _d_s
    days since current time. When job time is reached then signal _s_i_g
    will be sent to interface _n_a_m_e with type _i_f_t. Returns new shedule
    job identifier if shedule set successful or -1 otherwise.
	Reenterability: thread-safe
	Cancellation point: no

  void KKiillllTTiimmeerr (tid_t _t_i_d);
    Aborts shedule job with identifier _t_i_d. Returns nothing.
	Reenterability: thread-safe
	Cancellation point: no

  int CChheecckkFFlloooodd (short *_c_o_u_n_t_e_r, short _f_l_o_o_d_t_y_p_e[2]);
    Sets new flood entry. Value of _c_o_u_n_t_e_r checked for max value from
    _f_l_o_o_d_t_y_p_e[0]. Counter will be decremented after _f_l_o_o_d_t_y_p_e[1] seconds
    since call. Returns >0 if flood was detected.
	Reenterability: none

  void NNooCChheecckkFFlloooodd (short *_c_o_u_n_t_e_r);
    Aborts all flood entries for given _c_o_u_n_t_e_r. Returns nothing.
	Reenterability: none

Scripts API:
------------
#include "init.h"

  char *BBiinnddRReessuulltt;
    Contains string result of last executed binding.
	Reenterability: none

  time_t SSttaarrttTTiimmee;
    Contains time when client core was started.
	Reenterability: none

  char *DDaatteeSSttrriinngg;
    Contains current date in the form "%e %b" (see man strftime).
	Reenterability: none

  char *TTiimmeeSSttrriinngg;
    Contains current time in the form "%H:%M" (see man strftime).
	Reenterability: none

  time_t TTiimmee;
    Contains current local UNIX time.
	Reenterability: none

  int RReeggiisstteerrFFuunnccttiioonn (const char *_c_m_d, int (*_f_u_n_c)(const char *),
			const char *_m_s_g);
    Registers the function _f_u_n_c() in all interpreters with name _c_m_d.
    Optional message _m_s_g may be used in prompt by config generator.
    Returns 1 if function was registered.
      Function _f_u_n_c() gets string arguments (may be with ending spaces)
    and returns 0 on error or any other value otherwise. Return value is
    dependent on called function. In case of error BindResult may contain
    some error message or may be left untouched. Since the function can
    be used in config file it must allow duplicate calls, possibly with
    updated arguments.
	Reenterability: none

  int UUnnrreeggiisstteerrFFuunnccttiioonn (const char *_c_m_d);
    Deletes function with name _c_m_d from all interpreters. Returns 1 if
    function was deleted. You always have to call this function when
    module terminating for each command that was added on module init.
	Reenterability: none

  int RReeggiisstteerrBBoooolleeaann (const char *_b_o_o_l, bool *_v_a_r);
    Registers boolean variable _v_a_r in all interpreters with name _b_o_o_l.
    Returns 1 if variable was registered.
	Reenterability: none

  int RReeggiisstteerrIInntteeggeerr (const char *_i_n_t, long int *_v_a_r);
    Registers integer variable _v_a_r in all interpreters with name _i_n_t.
    Returns 1 if variable was registered.
	Reenterability: none

  int RReeggiisstteerrSSttrriinngg (const char *_s_t_r, char *_p_t_r, size_t _c_o_u_n_t, int _r_o);
    Registers string variable at address _p_t_r with size of _c_o_u_n_t bytes in
    all interpreters with name _s_t_r. If _r_o is not 0, attempt of change
    that variable will cause script interpreter error. Returns 1 if
    variable was registered.
	Reenterability: none

  int UUnnrreeggiisstteerrVVaarriiaabbllee (const char *_v_a_r);
    Deletes any variable with name _v_a_r from all interpreters. Returns 1
    if variable was deleted. You always have to call this function when
    module terminating for each variable that was added on module init.
	Reenterability: none

  short *FFllooooddTTyyppee (const char *_n_a_m_e);
    Creates new or finds existing flood structure associated with given
    _n_a_m_e. Returns pointer to flood pair (see CheckFlood() function).
	Reenterability: none

  char *SSeettFFoorrmmaatt (const char *_n_a_m_e, char *_v_a_l);
    Creates new or finds existing format string with max size FORMATMAX
    that associated with given _n_a_m_e, and updates it with _v_a_l. Returns
    pointer to that string.
	Reenterability: none

  int SSaavvee__FFoorrmmaattss (void);
    Saves all formats into file with path (char *)FormatsFile as strings
    "name value", overwriting file if exist. Returns 0 on success.
	Reenterability: none

  int CCoonnffiigg__EExxeecc (const char *_c_m_d, const char *_a_r_g_s);
    Runs function that was registered via RegisterFunction(). Function
    _c_m_d will get one argument - text string _a_r_g_s. Returns value that was
    returned by _c_m_d(_a_r_g_s). Note: this function can also run few built-in
    config file commands ("set", "script", and "flood-type") so this is
    the only way to run them not from config file.
	Reenterability: none

  bool CCoonnffiirrmm (char *_m_e_s_s_a_g_e, bool _d_e_f_l);
    Waits until user (via module "ui") confirm (i.e. enters "y" or "n")
    and then returns TRUE or FALSE. User will get prompt composed from
    _m_e_s_s_a_g_e and default value from _d_e_f_l. Returns immediately if that
    variable _d_e_f_l doesn't need to be asked (has no flag ASK) or if "ui"
    module doesn't exist. In that case returns TRUE or FALSE from _d_e_f_l.
    Note: don't lock dispatcher before Confirm() or you'll get freeze
    or even deadlock!
	Reenterability: may be called only from threads
	Cancellation point: yes

Sockets API:
------------
#include "socket.h"

  idx_t GGeettSSoocckkeett (unsigned short _m_o_d_e);
    Creates new socket. Socket must be sets up by SetupSocket() later and
    it will have requested _m_o_d_e. Returns new socket identifier or -1 if
    failed. Note: that socket must be owned by thread that called this
    GetSocket() and closed only by it.
	Reenterability: thread-safe
	Cancellation point: no (?)

  int SSeettuuppSSoocckkeett (idx_t _i_d_x, const char *_d_o_m_a_i_n, unsigned short _p_o_r_t,
		   int (*_c_a_l_l_b_a_c_k)(const struct sockaddr *_s_a, void *_c_b_d),
		   void *_c_b_d);
    Sets up new socket in non-block mode, establishes connection with
    Internet address with name _d_o_m_a_i_n to port _p_o_r_t if its mode is M_RAW
    or opens a new listening socket if its mode is M_LIST, M_LINP, or
    M_UNIX. If socket mode is M_LINP then listening socket will be opened
    only for single connection. Parameter _p_o_r_t is ignored when listening
    Unix socket (socket mode is M_UNIX). Returns 0 on success or error
    code otherwise. If _c_a_l_l_b_a_c_k is not NULL then function _c_a_l_l_b_a_c_k will
    be called with address _s_a and callback data _c_b_d as last step of the
    socket setup.
	Reenterability: thread-safe
	Cancellation point: yes

  idx_t AAnnsswweerrSSoocckkeett (idx_t _i_d_x);
    Attempts to answer for listening socket _i_d_x. Returns new socket
    identifier or -1 if no connections was made. Note: never cancel the
    thread where there is this call or you may get deadlock.
	Reenterability: thread-safe
	Cancellation point: yes

  int KKiillllSSoocckkeett (idx_t *_i_d_x);
    Closes the socket with identifier _i_d_x. Returns 0 if socket closed
    OK, -1 otherwise. Note: this function must be called by and only
    by thread that opened the socket before.
	Reenterability: thread-safe
	Cancellation point: maybe

  const char *SSoocckkeettDDoommaaiinn (idx_t _i_d_x, unsigned short *_p);
    Returns domain name for socket _i_d_x. If _p is not NULL then also puts
    port of the socket in *_p. If socket is opened in listen mode then
    returns own domain and port. If no matched socket found then _p will
    be left untouched and function returns empty string but no NULL.
	Reenterability: async-safe

  const char *SSoocckkeettIIPP (idx_t _i_d_x);
    Returns textual representation (name) for IP of socket _i_d_x. If socket
    is opened in listen mode then returns listening IP name. If there is
    no such socket then returns empty string but no NULL.
	Reenterability: async-safe

  char *SSoocckkeettEErrrroorr (int _e_r_r, char *_b_u_f, size_t _s_z);
    Returns text in buffer _b_u_f of size _s_z that describing error code _e_r_r
    that was returned by function SetupSocket() or ReadSocket(). Returns
    value of _b_u_f.
	Reenterability: async-safe

  ssize_t RReeaaddSSoocckkeett (char *_b_u_f, idx_t _i_d_x, size_t _s_z);
    Reads raw data from socket _i_d_x to buffer _b_u_f of max size _s_z and then
    returns size of read data. If called from threads then may wait up to
    200 milliseconds. If there was an error on socket then returns error
    code and if socket was died unexpectedly then returns E_NOSOCKET.
    Also may return E_AGAIN if socket is waiting for a connection.
	Reenterability: thread-safe
	Cancellation point: maybe

  ssize_t WWrriitteeSSoocckkeett (idx_t _i_d_x, const char *_b_u_f, size_t *_p_t_r,
		       size_t *_s_z);
    Writes raw data of size _s_z to socket _i_d_x from buffer _b_u_f at _p_t_r. If
    called from threads then may wait up to 200 milliseconds. Returns
    number of bytes written and changes counters _p_t_r and _s_z. If there was
    an error on socket then returns error code and if socket was died
    unexpectedly then returns E_NOSOCKET.
	Reenterability: thread-safe
	Cancellation point: maybe

Direct client's connections API:
--------------------------------
#include "direct.h"

  void DDcccc__PPaarrssee (struct peer_t *_s, char *_n_a_m_e, char *_c_m_d, userflag _g_f,
		  userflag _c_f, int _i_d_x, int _b_o_t_c_h,
		  struct bindtable_t *_s_s_b_t, char *_s_e_r_v_i_c_e);
    Parses text line _c_m_d that came from session _s. If first char of _c_m_d
    is not period ('.') then sends text line to botnet channel _b_o_t_c_h.
    Else if there is service specific bindtable _s_s_b_t (for _s_e_r_v_i_c_e) then
    checks first word of the line for available command in it. If no
    such bindtable or command is not found in it then checks first word
    of the line in bindtable "dcc". If there is appropriate command then
    runs function for it or else sends usage tip into _s. Does logging if
    command was successful. Login _n_a_m_e, direct access flags _g_f, service
    access flags _c_f, and socket ID _i_d_x are for client of the session _s.
    This function can be used for any valid peer but it's not advisable
    to use it for anything but direct session because bindings or usage
    tip may break interface protocol otherwise. Returns nothing.
	Reenterability: none

  int LLiisstteenn__PPoorrtt (char *_c_l_n, const char *_l_h_o_s_t, unsigned short _p,
		   char *_c_o_n_f_l_i_n_e, void *_i_d,
		   int (*_l_c_b) (const struct sockaddr *_s_a, void *_i_d),
		   void (*_p_r_e_h_a_n_d_l_e_r) (pthread_t _t_h, void **_i_d, idx_t *_a_s),
		   void (*_h_a_n_d_l_e_r) (char *_c_l_n, char *_i_d_e_n_t,
				    const char *_r_h_o_s_t, void *_i_d));
    Opens listener for client name _c_l_n on port _p. _l_h_o_s_t is host name on
    which listener will be opened (if it is NULL then listener will be
    opened on all local IPs). If _p is 0 then tries ports accordingly to
    variable "dcc-port-range". It creates thread where opens a listening
    socket and when connection is accepted then creates new thread where
    gets ident (see RFC1413) for incoming connection and then passes data
    of new connection (client name _c_l_n and value _i_d from caller, and
    _i_d_e_n_t and _r_h_o_s_t from input connection) to function _h_a_n_d_l_e_r (in that
    accepting thread). Returns 0 if the listening thread was created
    succesfully or returns error code otherwise. If callback function _l_c_b
    is not NULL then it will be called from the listening thread after
    finishing of socket setup. In case of any errors _l_c_b will be called
    with _s_a equal to NULL. In case of success _l_c_b still can return some
    error code to raise the error. In both cases _l_c_b should inform caller
    thread to take care of data _i_d. In any case those data will be freed
    by listening thread so should never be freed or accessed from ouside
    of the listening thread (also note: to prevent memory leak those data
    should not contain any allocated data). The callback _l_c_b should be
    thread-safe and may return E_AGAIN to make a retry. If _c_o_n_f_l_i_n_e is
    not NULL then this port will be reported to config as _c_o_n_f_l_i_n_e. The
    listening thread interface created in dispatcher with name _c_o_n_f_l_i_n_e
    (or with name consisting of opened port number if _c_o_n_f_l_i_n_e is NULL)
    and with type I_LISTEN. If _c_l_n is not NULL then listening socket will
    be closed as soon as connection was accepted. If _p_r_e_h_a_n_d_l_e_r is not
    NULL then it will be called from the listening thread each time when
    connection is accepted with new thread identifier _t_h, pointer to _i_d,
    and the accepted socket ID _a_s so caller may cancel that thread on
    emergency. Canceling of the listening thread is disabled while the
    _p_r_e_h_a_n_d_l_e_r is called. Data in _i_d are owned by the created interface
    on call of _p_r_e_h_a_n_d_l_e_r so that function should make a local copy if
    the accepting thread requires it or replace it with NULL otherwise.
    The _p_r_e_h_a_n_d_l_e_r should remember _a_s in optionally created data _i_d and
    if pointer in _i_d is NULL after call to _p_r_e_h_a_n_d_l_e_r then _h_a_n_d_l_e_r will
    be called with _i_d that points to _a_s instead so _h_a_n_d_l_e_r can know it in
    any case. In case if any error happened in the listening thread then
    _p_r_e_h_a_n_d_l_e_r will be called with _a_s equal to -1 and undefined _t_h to
    notify caller about that. Since that might be also as result of
    thread cancellation, _p_r_e_h_a_n_d_l_e_r should not call any but async-safe
    functions in that case. Accepting thread will wait for data returned
    by _p_r_e_h_a_n_d_l_e_r before calling the _h_a_n_d_l_e_r and pass that data to it.
    Socket of accepted connection is owned by the listening thread and
    inherited by the accepting thread (so function _h_a_n_d_l_e_r at the end).
    Note: if _p is 0 then _l_c_b is the only way to let caller know which
    port is listening in real.
	Reenterability: none

  int CCoonnnneecctt__HHoosstt (const char *_h_o_s_t, unsigned short _p_o_r_t, pthread_t *_t_h,
		    idx_t *_s_o_c_k_e_t, void (*_h_a_n_d_l_e_r) (int _r_e_s, void *_i_d),
		    void *_i_d);
    Attempts to create a thread to open outgoing connection to some _h_o_s_t
    on some _p_o_r_t. It does DNS lookup then opens connection. After that
    (eighter success or failure) given _h_a_n_d_l_e_r will be called with two
    parameters: error code _r_e_s and value _i_d from caller. The thread is
    joinable and caller gets identifiers _t_h of the thread and _s_o_c_k_e_t of
    the socket which is waiting for connection at that moment. Socket is
    owned by created thread. Returns 1 if there was no errors and thread
    is created or 0 otherwise.
	Reenterability: async-safe

  int CChheecckk__PPaasssswwdd (const char *_p_l_a_i_n, char *_e_n_c_r);
    Checks if _p_l_a_i_n text password has the same encrypted value as _e_n_c_r.
    Returns 0 if password matches.
	Reenterability: none

Connection chain API:
---------------------
#include "direct.h"

  int CCoonnnncchhaaiinn__GGrrooww (struct peer_t *_p_e_e_r, char _f);
    Adds filter of type _f at top of connection chain of _p_e_e_r. Returns 1
    if filter was added, 0 if filter not found, and -1 in case of error
    (which may be in case of dead connection or in case when there is
    some filter with the same handlers in the chain already so that may
    be considered as duplicate filter try). You should always call this
    at least once before you can use any of functions Connchain_Put(),
    Connchain_Get(), Connchain_Kill(), Peer_Put(), or Peer_Get(). You
    must always call Connchain_Kill() for any peer where you created
    connection chain with Connchain_Grow(). Note: adding filters 'x' or
    'y' that are implemented in core will never return 0. Note2: there is
    a completely legal way to reset all connection chain by binding which
    setups that new filter so be careful.
    * Filter 'x' : on send adds CR+LF to end of line, accepts line with
      at most MB_LEN_MAX*MESSAGEMAX-1 chars including terminating null
      byte; on receive accepts raw stream, selects lines that are ended
      with LF or CR+LF and returns them one by one, replacing LF or CR+LF
      with null byte (that byte counts in return).
    * Filter 'y' : on send replaces each 0xFF byte with two 0xFF+0xFF as
      stated in RFC854; on receive does backward conversion into 0xFF,
      ignores any ECHO commands, answers "Y" on AYT, DON'T on WILL, WON'T
      on DO, and skips other RFC854 codes.
	Reenterability: none

  int CCoonnnncchhaaiinn__CChheecckk (struct peer_t *_p_e_e_r, char _f);
    Performs any checks that Connchain_Grow() does but does not actually
    add a filter into connection chain.
	Reenterability: none

  ssize_t CCoonnnncchhaaiinn__PPuutt (struct connchain_i **_c_c, idx_t _i_d_x, const char *_l_i_n_e,
			 size_t *_s);
    Tries to filter and send data of size _s from buffer _l_i_n_e through next
    link of connection chain _c_c for socket identifier _i_d_x. If _l_i_n_e is
    NULL then it tries to send what is still left in chain's own buffers
    and in that case either returns error (if nothing left to send into
    socket _i_d_x) or number of bytes sent (i.e. 0). If _l_i_n_e isn't NULL but
    _s contains 0 then it returns value CONNCHAIN_READY in case when chain
    can take data for sending on next call or some other value otherwise.
    If there are data to send and there were no errors encountered then
    appropriately updates counter at _s and returns number of bytes that
    were sent. It will use N_POLL socket writing mode if peer state is
    P_DISCONNECTED or P_INITIAL. This function should never close or
    destroy the socket.
	Reenterability: async-safe

  ssize_t CCoonnnncchhaaiinn__GGeett (struct connchain_i **_c_c, idx_t _i_d_x, char *_b_u_f,
			 size_t _s);
    Tries to receive and filter data from socket _i_d_x through connection
    chain _c_c and put them into buffer _b_u_f of maximum size _s. If _b_u_f is
    NULL then chain will be destroyed immediately. If there was an error
    on receiving data then chain will return data that still left in
    buffers and if no data left then chain will be destroyed. If socket
    is still waiting for connection then it counts as error too. This
    function should never close or destroy the socket. It will use N_POLL
    socket reading mode if peer state is P_DISCONNECTED or P_INITIAL.
    Returns either error code or size of data that was received into _b_u_f.
	Reenterability: thread-safe
	Cancellation point: maybe

  CCoonnnncchhaaiinn__KKiillll (struct peer_t *_p_e_e_r);
    Macro, defined as: Connchain_Get(&_p_e_e_r->connchain,_p_e_e_r->socket,NULL,0)
    Used for terminating connection chain. Returns value E_NOSOCKET but
    generates warning if that value left unused. Typical usage of it is:
          if (Connchain_Kill(peer)) KillSocket(&peer->socket);
	Reenterability: thread-safe
	Cancellation point: maybe

  PPeeeerr__PPuutt (struct peer_t *_p_e_e_r, const char *_b_u_f, size_t *_s);
    Macro, defined as: Connchain_Put(&_p_e_e_r->connchain,_p_e_e_r->socket,_b_u_f,_s)
    Used for putting data on the top of connection chain.
	Reenterability: thread-safe
	Cancellation point: maybe

  PPeeeerr__GGeett (struct peer_t *_p_e_e_r, char *_b_u_f, size_t _s);
    Macro, defined as: Connchain_Get(&_p_e_e_r->connchain,_p_e_e_r->socket,_b_u_f,_s)
    Used for the getting data from the top of connection chain.
	Reenterability: thread-safe
	Cancellation point: maybe

Charset conversions API:
------------------------
#include "conversion.h"

  struct conversion_t *GGeett__CCoonnvveerrssiioonn (const char *_c_s);
    Allocates and returns conversion descriptor for charset name _c_s. If
    _c_s is not valid charset name then returns NULL. If _c_s is internal
    charset then returns NULL too.
	Reenterability: thread-safe
	Cancellation point: no

  void FFrreeee__CCoonnvveerrssiioonn (struct conversion_t *_c_o_n_v);
    Releases conversion descriptor _c_o_n_v. Returns nothing.
	Reenterability: thread-safe
	Cancellation point: no

  struct conversion_t *CClloonnee__CCoonnvveerrssiioonn (struct conversion_t *_c_o_n_v);
    Allocates and returns conversion descriptor that is equal to _c_o_n_v.
	Reenterability: thread-safe
	Cancellation point: no

  const char *CCoonnvveerrssiioonn__CChhaarrsseett (struct conversion_t *_c_o_n_v);
    Returns charset name for conversion descriptor _c_o_n_v.
	Reenterability: thread-safe
	Cancellation point: no

  size_t DDoo__CCoonnvveerrssiioonn (struct conversion_t *_c_o_n_v, char **_o_u_t,
			size_t _o_u_t_s_z, const char *_i_n, size_t _i_n_s_z);
    Does conversion of text line _i_n of size _i_n_s_z from charset defined by
    conversion descriptor _c_o_n_v to internal charset. Puts converted text
    into buffer _o_u_t of size _o_u_t_s_z. If there is no conversion need then
    on return variable by _o_u_t will contain value of _i_n. Returns size of
    converted line.
	Reenterability: thread-safe
	Cancellation point: no

  size_t UUnnddoo__CCoonnvveerrssiioonn (struct conversion_t *_c_o_n_v, char **_o_u_t,
			  size_t _o_u_t_s_z, const char *_i_n, size_t _i_n_s_z);
    Does conversion of text line _i_n of size _i_n_s_z from internal charset
    to charset defined by conversion descriptor _c_o_n_v. Puts converted
    text into buffer _o_u_t of size _o_u_t_s_z. If there is no conversion need
    then on return variable by _o_u_t will contain value of _i_n. Returns
    size of converted line.
	Reenterability: thread-safe
	Cancellation point: no

Calling of bindings:
--------------------
Flags:
  KEYWORD    matching of keyword (followed by space) to literal
  MASK       matching of string to mask
  MATCHCASE  case-sensitive matching of keyword to mask
  UNIQ       unique (replacing) binding for matching of keyword to literal
  UCOMPL     the same with completion
  UNIQMASK   unique (replacing) binding for matching of string to mask

All int func() returns 0 if binding did not executed. If binding executed
but result should be ignored (no logs for example) then func() may return
value -1. All bindings may be non-reenterable if another wasn't declared.

Interpreter entrance for bindings:
  int func(char *_f_n_a_m_e, int _a_r_g_c, const char *_a_r_g_v[]);
    Call interpreter function _f_n_a_m_e with _a_r_g_c arguments array _a_r_g_v (see
    the "Script args:" label below and if there is no such label on the
    bindtable then interpreter bindings will be never called even if some
    of them exist). If _f_n_a_m_e is "-" then interpreter should return its
    name. If binding returns text then that text should go into variable
    BindResult. In case of error it should put message describing error
    into log. Note: _a_r_g_c value can be from 0 to 8.

Builted in bindings: since C does not have possibility to have typedef for
  function, only way to have type control is to insert line composited from
  'BINDING_TYPE_' with bindtable name with dashes replaced by underscores
  and function name before binding's definition, for example:

    BINDING_TYPE_add_ui (au_test);	/* for bindtable "add-ui" */
    static int au_test (INTERFACE *iface, char *s)
    .......

  Since we want to avoid crashes, using this line is mandatory for every
  binding we create. Note: use BINDING_TYPE_ss_ for ss-* bindtables.
